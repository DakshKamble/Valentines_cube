#include <Adafruit_NeoPixel.h>
#include <Wire.h>
#include <U8g2lib.h>
#include "esp_sleep.h"

// ================= OLED =================
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);

// ================= HARDWARE SETTINGS =================
#define PHYSICAL_LED_COUNT 30 
#define ACTIVE_LED_COUNT   9 
#define BUTTON_LED_COUNT   3

// PINS
#define BUTTON_STRIP_PIN D9
#define BODY_STRIP_PIN   D8
#define BTN_YES_PIN      D1
#define BTN_NO_PIN       D2
#define BTN_YES_GPIO     GPIO_NUM_3 

Adafruit_NeoPixel buttonStrip(BUTTON_LED_COUNT, BUTTON_STRIP_PIN, NEO_GRB + NEO_KHZ800);
Adafruit_NeoPixel bodyStrip(PHYSICAL_LED_COUNT, BODY_STRIP_PIN, NEO_GRB + NEO_KHZ800);

// ================= TIMING =================
#define INACTIVITY_TIMEOUT   180000UL // 3min Sleep
#define CELEBRATION_DURATION 10000UL // 10s Love then Reset
#define DEBOUNCE_DELAY       50

// ================= BITMAP DATA =================
static const unsigned char image_cards_hearts_bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0x00,0x1c,0x1c,0x3e,0x3e,0x7f,0x7f,0xff,0x7f,0xff,0x7f,0xff,0x7f,0xfe,0x3f,0xfc,0x1f,0xf8,0x0f,0xf0,0x07,0xe0,0x03,0xc0,0x01,0x80,0x00,0x00,0x00};

static const unsigned char image_DolphinNice_bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0xf8,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x07,0x80,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0xe0,0x0f,0x00,0x00,0x0c,0xf8,0x00,0x00,0x00,0x00,0x00,0x08,0x10,0x10,0x00,0x80,0x1a,0x07,0x07,0x00,0x00,0x00,0x00,0x04,0x08,0x20,0x00,0x40,0xf5,0x00,0x08,0x00,0x00,0x00,0x00,0x02,0xc4,0x4f,0x00,0xa0,0x1e,0x00,0x10,0x00,0x00,0x00,0x00,0x02,0x64,0x5c,0x00,0xc0,0x03,0x00,0x20,0x00,0x00,0x00,0x00,0x02,0xe4,0x5c,0x00,0x60,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x02,0xe4,0x5c,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x01,0xe4,0x5f,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x01,0xe4,0x5f,0x00,0x00,0x00,0x80,0x47,0x00,0x00,0x00,0x00,0x01,0xca,0x2f,0x00,0x00,0x00,0x60,0x48,0x00,0x00,0x00,0x00,0x01,0x95,0x1f,0x00,0x00,0x00,0x1c,0x50,0x00,0x00,0x00,0x00,0x81,0x6a,0x20,0x00,0x00,0x80,0x03,0x20,0x00,0x00,0x00,0x00,0x01,0x15,0x00,0x00,0x00,0x60,0x00,0x20,0x00,0x00,0x00,0x00,0x81,0x0a,0x00,0x00,0x00,0x18,0x00,0x20,0x00,0x00,0x00,0x00,0x01,0x0d,0x00,0x00,0x00,0x06,0x00,0x20,0x00,0x18,0x00,0x00,0x01,0x0a,0x00,0x00,0x80,0x01,0x00,0x10,0x00,0x24,0x00,0x00,0x01,0x0c,0x00,0x00,0x60,0x00,0x00,0x10,0x00,0x44,0x00,0x00,0x01,0x08,0x08,0x00,0x18,0x00,0x00,0x08,0x00,0x84,0x07,0x00,0x01,0x00,0x30,0x00,0x06,0x00,0x00,0x04,0x00,0x44,0x18,0x00,0x01,0x00,0xc0,0x81,0x01,0x00,0x00,0x02,0x00,0x24,0x20,0x00,0x01,0x00,0x00,0x7e,0x00,0x00,0x40,0x01,0x00,0x24,0x40,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0xa8,0x00,0x00,0x14,0x80,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x74,0x00,0x00,0x12,0x80,0x00,0x01,0x00,0x00,0x00,0x00,0x80,0x1a,0x00,0x00,0x11,0x80,0x00,0x01,0x00,0x00,0x00,0x00,0x40,0x0d,0x00,0xc0,0x10,0x80,0x80,0x01,0x00,0x00,0x00,0x00,0xa8,0x02,0x00,0x30,0x20,0x80,0x80,0x03,0x00,0x00,0x00,0x40,0x55,0x01,0x00,0x0c,0x40,0x40,0xc0,0x03,0x00,0x00,0x00,0xaa,0xaa,0x01,0x00,0x03,0x80,0x3f,0xe0,0x03,0x00,0x00,0x00,0x55,0xd5,0x01,0xe0,0x00,0x00,0x10,0xe0,0x03,0x00,0x00,0x00,0xa8,0xaa,0x0f,0x1c,0x00,0x00,0x08,0xf0,0x03,0x00,0x00,0x00,0x00,0x55,0xfb,0x03,0x00,0x00,0x04,0xf0,0x03,0x00,0x00,0x00,0x00,0x00,0x56,0x00,0x00,0x00,0x02,0xf8,0x02,0x00,0x00,0x00,0x00,0x00,0x2a,0x01,0x00,0x00,0x01,0x78,0x03,0x00,0x00,0x00,0x00,0x00,0x54,0x00,0x00,0x80,0x00,0xbc,0x02,0x00,0x00,0x00,0x00,0x00,0xac,0x00,0x00,0x40,0x00,0x5c,0x05,0x00,0x00,0x00,0x00,0x00,0x58,0x02,0x00,0x20,0x00,0xbe,0x06,0x00,0x00,0x00,0x00,0x00,0xa8,0x00,0x00,0x10,0x00,0x5e,0x05,0x00,0x00,0x00,0x00,0x00,0x50,0x02,0x00,0x08,0x00,0xaf,0x06,0x00,0x00,0x00,0x00,0x00,0xb0,0x00,0x00,0x04,0x00,0x57,0x05,0x00,0x00,0x00,0x00,0x00,0x50,0x01,0x00,0x03,0x00,0xaf,0x06,0x00,0x00,0x00,0x00,0x00,0xa0,0x04,0x80,0x00,0x00,0x57,0x05,0x00,0x00,0x00,0x00,0x00,0x60,0x01,0x60,0x00,0x00,0xa3,0x06,0x00,0x00,0x00,0x00,0x00,0xa0,0x02,0x10,0x00,0x00,0x53,0x05,0x00,0x00,0x00,0x00,0x00,0x40,0x09,0x0c,0x00,0x00,0xa1,0x06,0x00,0x00,0x00,0x00,0x00,0xc0,0x02,0x03,0x00,0x00,0x41,0x05,0x00,0x00,0x00,0x00,0x00,0x40,0xe1,0x00,0x00,0x00,0xa1,0x06,0x00,0x00,0x00,0x00,0x00,0x80,0x1e,0x00,0x00,0x00,0x40,0x05,0x00,0x00,0x00,0x00,0x00,0x80,0x03,0x00,0x00,0x00};

static const unsigned char image_Connected_bits[] U8X8_PROGMEM = {0x00,0xf8,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0xc0,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x03,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x04,0x78,0x00,0x20,0x3c,0x00,0x00,0x00,0x04,0x84,0x00,0x40,0x43,0x00,0x00,0x00,0x02,0x7a,0x01,0xc0,0x80,0x00,0x00,0x00,0x02,0xdd,0x02,0x30,0x80,0xe0,0x00,0x00,0x02,0x9d,0x02,0x0c,0xf0,0x20,0x79,0x00,0x02,0xfd,0x02,0x03,0x7c,0x20,0x86,0x00,0x01,0xfd,0x02,0x00,0x3e,0x20,0x02,0x01,0x01,0xfa,0x01,0x80,0x1f,0x40,0x02,0x02,0x01,0x14,0x02,0xc0,0x0f,0x40,0x02,0x02,0x01,0x08,0x00,0xe0,0x07,0x40,0x02,0x02,0x01,0x08,0x00,0xf0,0x03,0x80,0x04,0x02,0x01,0x00,0x00,0xf8,0x01,0x80,0x18,0x01,0x01,0x00,0x01,0x86,0x7f,0x80,0xe0,0x01,0x01,0x00,0x86,0x01,0x9e,0x80,0x00,0x01,0x01,0x00,0xf8,0xff,0x81,0x80,0x00,0x01,0x01,0x00,0x00,0x00,0x80,0x40,0x00,0x01,0x01,0x00,0x00,0x00,0x40,0x40,0x00,0x01,0x01,0x00,0x00,0x00,0x38,0x40,0x00,0x01,0x01,0x00,0x00,0x00,0x06,0x20,0x00,0x01,0x01,0x00,0x00,0xff,0x01,0x20,0x00,0x01,0x01,0x00,0x00,0xfc,0x00,0x10,0x00,0x01,0x01,0x00,0x00,0x80,0x00,0x10,0x00,0x01};

static const unsigned char image_Error_bits[] U8X8_PROGMEM = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x0c,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x06,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x08,0xf0,0x00,0x40,0x00,0x00,0x03,0x18,0x08,0x08,0x01,0x80,0x00,0x00,0x07,0x1c,0x04,0xf4,0x02,0x80,0x7c,0x00,0x0e,0x0e,0x04,0xba,0x05,0x80,0x83,0x00,0x1c,0x07,0x04,0x3a,0x05,0x70,0x00,0x01,0xb8,0x03,0x04,0xfa,0x05,0x0e,0x00,0x02,0xf0,0x01,0x02,0xfa,0x05,0x00,0xc0,0x03,0xe0,0x00,0x02,0xf4,0x02,0x00,0x30,0x02,0xf0,0x01,0x02,0x08,0x01,0x00,0x0c,0x02,0xb8,0x03,0x02,0xf0,0x00,0x00,0x03,0x02,0x1c,0x07,0x02,0x00,0x00,0xc0,0x00,0x01,0x0e,0x0e,0x02,0x00,0x00,0x30,0x80,0x00,0x07,0x1c,0x02,0x00,0x00,0x0c,0x40,0x00,0x03,0x18,0x02,0x00,0x00,0x03,0x20,0x00,0x00,0x00,0x02,0x00,0x40,0x00,0x18,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x02,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0xe0,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0xf8,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00};

static const unsigned char image_passport_happy1_bits[] U8X8_PROGMEM = {0xfe,0xff,0xff,0xff,0xff,0x1f,0xff,0xff,0xff,0xff,0xff,0x3f,0xff,0x0f,0x80,0xff,0xff,0x3f,0xff,0xf1,0x7f,0xfe,0xff,0x3f,0xff,0x0e,0x80,0xf9,0xff,0x3f,0x7f,0x01,0x00,0xf6,0xff,0x3f,0xbf,0x00,0x00,0xe8,0xff,0x3f,0x5f,0x00,0x00,0xd0,0xff,0x3f,0x2f,0x00,0x00,0xd0,0x03,0x3f,0x17,0x00,0x00,0xa0,0xfc,0x3e,0x17,0x00,0x00,0x20,0x03,0x3d,0x0b,0x00,0x00,0xc0,0x00,0x3a,0x0b,0x00,0x00,0x20,0x00,0x3a,0x05,0xe0,0x00,0x10,0xe0,0x3b,0x05,0xf8,0x03,0x08,0xf8,0x3b,0x05,0xfc,0x03,0x04,0xfc,0x3d,0x03,0xfe,0x01,0x02,0xfe,0x3e,0x03,0x9e,0x07,0x00,0x7f,0x3f,0x03,0x4e,0x08,0x80,0xbf,0x3f,0x03,0x2e,0x00,0xc0,0xdf,0x3f,0x03,0x14,0x00,0xe0,0xef,0x3f,0x03,0x10,0x00,0xf0,0xf7,0x3f,0x03,0x10,0x00,0xf8,0xfb,0x3f,0x01,0x00,0x01,0xfc,0xf9,0x3f,0x01,0x00,0x01,0xfe,0xe7,0x3f,0x01,0x00,0x86,0x87,0x9f,0x3f,0x01,0x00,0xf8,0x03,0x7e,0x3e,0x01,0x00,0xe0,0x07,0xf8,0x39,0x01,0x00,0x00,0x7f,0xe0,0x37,0x01,0x00,0x00,0x80,0xff,0x2b,0x01,0x30,0x06,0x00,0x00,0x28,0x01,0x48,0x09,0x00,0x00,0x28,0x01,0x88,0x08,0x00,0x00,0x36,0x01,0x88,0x08,0x00,0xe0,0x39,0x01,0x84,0x10,0xfa,0x1f,0x3e,0x01,0x84,0x10,0xf0,0xe3,0x3f,0x01,0x82,0x20,0x80,0xfb,0x3f,0x01,0x82,0x20,0x00,0xfa,0x3f,0x01,0x81,0x40,0x00,0xfa,0x3f,0x01,0x81,0x40,0x00,0xf4,0x3f,0x81,0x80,0x80,0x00,0xf4,0x3f,0x41,0x80,0x00,0x01,0xf4,0x3f,0x41,0xc0,0x01,0x01,0xe8,0x3f,0x21,0xc0,0x01,0x02,0xe8,0x3f,0x11,0xc0,0x01,0x04,0xd0,0x3f,0x0d,0xe0,0x03,0x18,0xd0,0x3f,0x03,0xe0,0x03,0xe0,0xa0,0x3f,0x01,0xf0,0x07,0x00,0x67,0x3f,0xfe,0xff,0xff,0xff,0xff,0x1f};

static const unsigned char image_passport_bad1_bits[] U8X8_PROGMEM = {0xfe,0xff,0xff,0xff,0xff,0x1f,0xff,0xff,0xff,0xff,0xff,0x3f,0xff,0xff,0x01,0xf8,0xff,0x3f,0xff,0x7f,0xfe,0xe7,0xff,0x3f,0xff,0x9f,0x01,0x98,0xff,0x3f,0xff,0x6f,0x00,0x60,0xfe,0x3f,0xff,0x17,0x00,0x80,0xfd,0x3f,0xff,0x0b,0x00,0x00,0xfa,0x3f,0xff,0x05,0x00,0x00,0xf4,0x3f,0xff,0x02,0x00,0x00,0xf4,0x3f,0x7f,0x01,0x00,0x00,0xe8,0x3f,0xbf,0x00,0x00,0x00,0xe8,0x3f,0xbf,0x00,0x00,0x00,0xd0,0x3f,0x5f,0x00,0x06,0x00,0xd0,0x3f,0x5f,0x00,0x08,0x00,0xa0,0x3f,0x2f,0x00,0x10,0x00,0xa0,0x3f,0x2f,0x00,0x67,0x00,0xa0,0x3f,0x2f,0x80,0xce,0x01,0xa0,0x3f,0x17,0x40,0x9e,0x03,0xa0,0x3f,0x17,0x40,0x36,0x00,0xa0,0x3f,0x17,0x40,0x7e,0x00,0xa0,0x3f,0x17,0x40,0x7c,0x00,0xa0,0x3f,0x17,0x80,0x40,0x00,0xa0,0x3f,0x17,0xc0,0x3f,0x00,0xa0,0x3f,0x17,0x20,0x08,0x00,0xa0,0x3f,0x17,0x00,0x10,0x00,0xaa,0x3f,0x1b,0x00,0x00,0x00,0x30,0x3f,0x1b,0x00,0x00,0x00,0xc0,0x3e,0x1b,0x00,0x00,0x00,0x00,0x3d,0x1b,0x00,0x0e,0x00,0x00,0x3a,0x0d,0x00,0x31,0x00,0x00,0x34,0x0d,0x00,0xc0,0x00,0x00,0x28,0x0d,0x00,0x00,0x03,0x00,0x28,0x0d,0x00,0x00,0x0c,0x00,0x28,0x0b,0x00,0x00,0x30,0xf0,0x2b,0x0b,0x00,0x00,0xc0,0x0f,0x2c,0x0b,0x00,0x80,0x01,0x00,0x28,0x09,0x00,0x00,0x0e,0x00,0x34,0x09,0x00,0x00,0xfc,0x00,0x3b,0x09,0x00,0x00,0xf0,0xff,0x3d,0x09,0x00,0x00,0xc0,0x7f,0x3e,0x09,0x00,0x00,0x00,0xbf,0x3f,0x09,0x00,0x00,0x00,0xbc,0x3f,0x09,0x00,0x00,0x00,0xa0,0x3f,0x09,0x00,0x00,0x00,0xa0,0x3f,0x09,0x00,0x00,0x00,0xa0,0x3f,0x09,0x00,0x00,0x00,0xa0,0x3f,0x09,0x00,0x00,0x00,0xa0,0x3f,0xfe,0xff,0xff,0xff,0xff,0x1f};

static const unsigned char image_Scanning_bits[] U8X8_PROGMEM = {0x00,0xc0,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x07,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xac,0x03,0x18,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x56,0x05,0x60,0x00,0x00,0x00,0x80,0x02,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x81,0x0a,0x80,0x00,0x00,0x00,0x80,0x02,0x00,0x00,0x00,0x00,0x04,0x00,0x80,0x00,0x15,0x00,0x01,0x00,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x02,0x00,0x40,0x00,0x38,0x00,0x02,0x00,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x82,0x00,0x20,0x00,0x74,0x00,0x04,0x00,0x00,0x40,0x82,0x01,0x00,0x00,0x00,0x41,0x00,0x20,0x00,0x68,0x00,0x04,0x00,0x00,0x20,0x82,0x02,0x06,0x00,0x00,0x21,0x00,0x10,0x00,0xd0,0xe0,0x0f,0x00,0x00,0x20,0x82,0x02,0x0a,0x0c,0x80,0x20,0x08,0x10,0x00,0xa0,0x1c,0x10,0x00,0x00,0x20,0x82,0x02,0x0a,0x14,0x80,0x10,0x04,0x08,0xe0,0xd3,0x03,0x10,0x00,0x00,0x10,0x82,0x02,0x0a,0x14,0x80,0x10,0x02,0x08,0x90,0xa7,0x40,0x24,0x00,0x00,0x10,0x82,0x02,0x0a,0x14,0x80,0x10,0x02,0x08,0xc8,0x7f,0x84,0x28,0x00,0x00,0x10,0x84,0x02,0x0a,0xff,0x80,0x10,0x02,0x88,0x67,0x3e,0x88,0x28,0x00,0x00,0x10,0x84,0xfa,0xff,0xff,0x80,0x10,0x02,0x44,0x64,0x2e,0x88,0x28,0x00,0x00,0x10,0xfc,0xaf,0xff,0x15,0x80,0x10,0x04,0x44,0xe4,0x2f,0x88,0x2a,0x00,0x00,0x18,0xd4,0xdf,0x1f,0x14,0x80,0x20,0x08,0x44,0xe4,0x2f,0x50,0xff,0x00,0xfe,0x1f,0xec,0x3f,0x0a,0x14,0x00,0x21,0x00,0x44,0xc4,0x2f,0xea,0x00,0x01,0x01,0x1a,0xfc,0x02,0x0a,0x14,0x00,0x41,0x00,0x84,0x88,0x2f,0x1d,0x00,0x82,0x7d,0x1e,0x84,0x02,0x0a,0x18,0x00,0x82,0x00,0x86,0x1f,0xc6,0x06,0x00,0x84,0x7d,0x16,0x84,0x02,0x0a,0x00,0x00,0x02,0x00,0x46,0xf5,0xc3,0x01,0x00,0x44,0x01,0x22,0x84,0x02,0x0c,0x00,0x00,0x04,0x00,0x87,0x0a,0x7c,0x00,0x00,0x44,0x03,0x22,0x88,0x02,0x00,0x00,0x00,0x08,0x00,0x45,0x05,0x08,0x00,0x7e,0xa4,0x03,0x42,0x88,0x02,0x00,0x00,0x00,0x10,0x00,0x86,0x06,0x00,0xc0,0x81,0xa5,0x07,0x42,0x08,0x03,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x30,0x00,0xd2,0xff,0x81,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x0c,0x00,0xd2,0x1f,0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x80,0x00,0x03,0x00,0xd1,0x1f,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0xe1,0x00,0x80,0xe9,0x0f,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x1e,0x00,0xc0,0xe8,0x0f,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x70,0xee,0x0f,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x3c,0xf9,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0xaa,0x9f,0xf0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x40,0x55,0xfd,0x5f,0xf0,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0xea,0xff,0x3f,0xe0,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x40,0xd5,0xff,0x1f,0xe0,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x80,0xaa,0xff,0x0f,0xe0,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x55,0x55,0x03,0xf0,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0xaa,0xaa,0x00,0xb0,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x54,0x75,0x00,0x58,0x0d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0xa8,0x0f,0x00,0xa8,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x7c,0x00,0x00,0x5c,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0xae,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x00,0xd7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x80,0x7b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x00,0x00,0x00,0xc0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2a,0x00,0x00,0x00,0xf0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0x00,0x00,0x00,0xfc,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0x00,0x00,0x00,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

// ================= TEXT CONFIGURATION (EDIT HERE) =================
// 0. INTRO SEQUENCE
const char* MSG_INTRO_1 = "I am a dumb\nfucking cube";
const char* MSG_VALENTINE_CHECK = "is valentines\nnext week?";
const char* MSG_GOODNIGHT = "oops!\nsorry";
const char* MSG_REMEMBER = "remember";
const char* MSG_GREEN_YES = "GREEN means yes";
const char* MSG_RED_NO = "RED means no";
const char* MSG_INTRO_2_1 = "i have only one";
const char* MSG_INTRO_2_2 = "purpose";
const char* MSG_INTRO_3 = "that is to ask you";
const char* MSG_INTRO_4_1 = "do you think";
const char* MSG_INTRO_4_2 = "im cute???";
const char* MSG_CUTE_YES = "knew it";
const char* MSG_CUTE_NO = "wrong answer";
const char* MSG_INTRO_5 = "now for the\nactual question";
const char* MSG_INTRO_6 = "my owner\nwants to ask you";

// 1. BOOT SCREEN
const char* MSG_BOOT_1 = "Gargi, will you be";
const char* MSG_BOOT_2 = "my Valentine?‚Å†";

// 2. IDLE MODE (ESCALATING "NO" RESPONSES)
const char* NO_RESPONSES[] = { 
  "Abe??", 
  "HO????", 
  "i know where\nyour mom lives" 
};
const int TRIGGER_COUNT = 4; // Trick happens on 4th press

// 3. SWAP TRICK MODE
const char* MSG_TRICK_PROMPT = "Ab kya karegi tu?";
const char* MSG_TRICK_REVEAL = "You pressed YES!";

// 4. FAIR RIGHT MODE
const char* MSG_FAIR_1 = "Finally! That";
const char* MSG_FAIR_2 = "was fair right?";

// 5. CONTROL MODE (If they say No to Fair Right)
const char* MSG_CONTROL_1 = "im controlling you";
const char* MSG_CONTROL_2 = "now!!!!";
const char* MSG_CONTROL_3 = "SAY YES!!!";

// 6. VICTORY MESSAGES
// Standard Win (Immediate Yes)
const char* MSG_WIN_STD_1 = "SHE SAID YES!";
const char* MSG_WIN_STD_2 = "HAPPY VALENTINE";
const char* MSG_WIN_STD_3 = "<3 <3 <3";

// Final Win (After begging)
const char* MSG_WIN_FINAL_1 = "SHE SAID YES!";
const char* MSG_WIN_FINAL_2 = "(FINALLY!)";
const char* MSG_WIN_FINAL_3 = "<3 <3 <3";

// 6. JOB COMPLETION SEQUENCE
const char* MSG_JOB_DONE_1 = "with that my";
const char* MSG_JOB_DONE_2 = "job here is done";
const char* MSG_LEAVE_QUESTION = "Should i fuck\noff now?";
const char* MSG_CANT_CONTROL_1 = "you cant control me";
const char* MSG_CANT_CONTROL_2 = "i have rights";
const char* MSG_JOB_GOODNIGHT = "Goodnight...";  // For job completion sequence

// 7. SLEEP
const char* MSG_SLEEP_1 = "Goodnight...";
const char* MSG_SLEEP_2 = "<3";


// ================= STATE MACHINE =================
enum AppState {
  STATE_INTRO_DOLPHIN,   // Dolphin "HI!" screen
  STATE_INTRO_1,         // "I am a dumb cube"
  STATE_VALENTINE_CHECK, // "Is valentines next week?"
  STATE_GOODNIGHT,       // "oops! goodnight" before sleep
  STATE_INTRO_REMEMBER,  // "remember"
  STATE_INTRO_GREEN,     // "GREEN means yes" with Connected icon
  STATE_INTRO_RED,       // "RED means no" with Error icon
  STATE_INTRO_2,         // "i have only one purpose"
  STATE_INTRO_3,         // "that is to ask you"
  STATE_INTRO_4,         // "do you think im cute???"
  STATE_CUTE_RESPONSE,   // "knew it" or "wrong answer"
  STATE_INTRO_5,         // "now for the actual question"
  STATE_INTRO_6,         // "my owner wants to ask you"
  STATE_IDLE,            // "Will you be my Valentine?"
  STATE_NO_RESPONSE,     // Showing NO response message
  STATE_SWAP_MODE,       // Trick mode
  STATE_FAIR_RIGHT,      // "Fair right?" (Yes/No available)
  STATE_FINAL_PLEA,      // Control mode (Force Win)
  STATE_CELEBRATION,     // "She said YES!"
  STATE_JOB_DONE,        // "with that my job here is done"
  STATE_LEAVE_QUESTION,  // "Should i fuck off now?"
  STATE_DEFIANT_RESPONSE // "you cant control me i have rights"
};

AppState currentState = STATE_INTRO_DOLPHIN;

// Logic Variables
int noCount = 0;
unsigned long lastActivityTime = 0;
unsigned long stateStartTime = 0; 
bool isTrickReveal = false;
bool lastCuteResponseWasYes = false;

// Non-blocking timer system
unsigned long noResponseDisplayTime = 0;
bool showingNoResponse = false;
bool noResponseTimerStarted = false;
unsigned long typewriterStartTime = 0;
int typewriterCharIndex = 0;
bool typewriterActive = false;
String typewriterText1 = "";
String typewriterText2 = "";
String typewriterText3 = "";
int typewriterLine = 1;
unsigned long trickRevealStartTime = 0;
bool trickRevealWaiting = false;
unsigned long controlScreenStartTime = 0;
bool showingControlScreen2 = false; 

// Button Debounce Variables
unsigned long lastDebounceTime = 0;
bool btnYesStable = HIGH;
bool btnNoStable = HIGH;
bool lastBtnYesReading = HIGH;
bool lastBtnNoReading = HIGH;

// Forward declarations
void updateLEDs();
void showDolphinScreen();
void showIntroMessage(const char* message);
void showRememberScreen();
void showGreenYesScreen();
void showRedNoScreen();
void showPassportHappyScreen();
void showPassportBadScreen();
void showControlScreen1();
void showControlScreen2();
void showValentineScreen();
void startNonBlockingTypewriter(const char* l1, const char* l2 = NULL, const char* l3 = NULL);
void updateNonBlockingTypewriter();
void startNoResponseTimer(); 

// ================= HARD RESET =================
void forceHardReset() {
  buttonStrip.begin();
  bodyStrip.begin();
  buttonStrip.clear();
  bodyStrip.clear();
  buttonStrip.show();
  bodyStrip.show();
  delay(20); 
  buttonStrip.setBrightness(150); // Soft brightness
  bodyStrip.setBrightness(150);
}

// ================= DISPLAY HELPERS (TYPEWRITER) =================
void oledTypewriter(const char* l1, const char* l2 = NULL, const char* l3 = NULL) {
  u8g2.setFont(u8g2_font_t0_13b_tr);
  
  char buf1[32] = "";
  char buf2[32] = "";
  char buf3[32] = "";
  
  // --- TYPE LINE 1 ---
  if (l1) {
    int len = strlen(l1);
    for(int i=0; i<len; i++) {
      buf1[i] = l1[i];
      buf1[i+1] = '\0';
      
      u8g2.clearBuffer();
      int w = u8g2.getStrWidth(buf1);
      int x = (128-w)/2;
      int y = l2 ? 25 : 36;
      u8g2.drawStr(x, y, buf1);
      u8g2.drawStr(x + w + 1, y, "_"); 
      u8g2.sendBuffer();
      
      updateLEDs(); // KEEP ANIMATIONS ALIVE!
      delay(30 + random(30)); 
    }
  }

  // --- TYPE LINE 2 ---
  if (l2) {
    int len = strlen(l2);
    for(int i=0; i<len; i++) {
      buf2[i] = l2[i];
      buf2[i+1] = '\0';
      
      u8g2.clearBuffer();
      int w1 = u8g2.getStrWidth(l1); u8g2.drawStr((128-w1)/2, 25, l1);
      
      int w2 = u8g2.getStrWidth(buf2);
      int x = (128-w2)/2;
      u8g2.drawStr(x, 45, buf2);
      u8g2.drawStr(x + w2 + 1, 45, "_"); 
      u8g2.sendBuffer();
      updateLEDs();
      delay(30 + random(30));
    }
  }

  // --- TYPE LINE 3 ---
  if (l3) {
    int len = strlen(l3);
    for(int i=0; i<len; i++) {
      buf3[i] = l3[i];
      buf3[i+1] = '\0';
      
      u8g2.clearBuffer();
      int w1 = u8g2.getStrWidth(l1); u8g2.drawStr((128-w1)/2, 25, l1);
      int w2 = u8g2.getStrWidth(l2); u8g2.drawStr((128-w2)/2, 45, l2);
      
      int w3 = u8g2.getStrWidth(buf3);
      int x = (128-w3)/2;
      u8g2.drawStr(x, 60, buf3);
      u8g2.drawStr(x + w3 + 1, 60, "_"); 

      u8g2.sendBuffer();
      updateLEDs();
      delay(30 + random(30));
    }
  }

  // Final render
  u8g2.clearBuffer();
  if(l1) { int w = u8g2.getStrWidth(l1); u8g2.drawStr((128-w)/2, l2?25:36, l1); }
  if(l2) { int w = u8g2.getStrWidth(l2); u8g2.drawStr((128-w)/2, 45, l2); }
  if(l3) { int w = u8g2.getStrWidth(l3); u8g2.drawStr((128-w)/2, 60, l3); }
  u8g2.sendBuffer();
}

// ================= ANIMATIONS =================
void animBoot() {
  u8g2.clearBuffer(); u8g2.sendBuffer();
  
  // 1. Soft Pink Flow (Body)
  for(int i=0; i<ACTIVE_LED_COUNT; i++) {
    bodyStrip.setPixelColor(i, bodyStrip.Color(180, 50, 80)); 
    bodyStrip.show();
    delay(40);
  }

  // 2. Button Wakeup
  for(int b=0; b<200; b+=5) {
      buttonStrip.setPixelColor(1, buttonStrip.Color(b, b/2, b/2)); 
      buttonStrip.show();
      delay(5);
  }
  buttonStrip.setPixelColor(1, 0); 

  // Fade in buttons
  for(int b=0; b<255; b+=5) {
    buttonStrip.setPixelColor(0, buttonStrip.Color(b, 0, 0)); // RED
    buttonStrip.setPixelColor(2, buttonStrip.Color(0, b, 0)); // GREEN
    buttonStrip.show();
    delay(5);
  }
  
  // Show dolphin intro screen
  showDolphinScreen();
}

// ================= INTRO SCREEN FUNCTIONS =================
void showDolphinScreen() {
  u8g2.clearBuffer();
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);
  u8g2.setFont(u8g2_font_t0_13b_tr);
  
  // Typewriter "HI!"
  char buf[4] = "";
  const char* text = "HI!";
  int len = strlen(text);
  
  for(int i=0; i<=len; i++) {
    if(i < len) {
      buf[i] = text[i];
      buf[i+1] = '\0';
    }
    
    u8g2.clearBuffer();
    u8g2.drawXBMP(7, 3, 96, 59, image_DolphinNice_bits);
    u8g2.drawStr(92, 17, buf);
    if(i < len) u8g2.drawStr(92 + u8g2.getStrWidth(buf) + 1, 17, "_");
    
    u8g2.sendBuffer();
    updateLEDs();
    delay(80 + random(40));
  }
  
  // Final display
  u8g2.clearBuffer();
  u8g2.drawXBMP(7, 3, 96, 59, image_DolphinNice_bits);
  u8g2.drawStr(92, 17, text);
  u8g2.sendBuffer();
}

void showIntroMessage(const char* message) {
  startNonBlockingTypewriter(message);
}

void showRememberScreen() {
  startNonBlockingTypewriter(MSG_REMEMBER);
}

void showGreenYesScreen() {
  u8g2.setFont(u8g2_font_t0_13b_tr);
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);
  
  char buf[32] = "";
  const char* text = MSG_GREEN_YES;
  int len = strlen(text);
  
  for(int i=0; i<=len; i++) {
    if(i < len) {
      buf[i] = text[i];
      buf[i+1] = '\0';
    }
    
    u8g2.clearBuffer();
    u8g2.drawXBMP(34, 7, 58, 30, image_Connected_bits);
    u8g2.drawStr(11, 56, buf);
    if(i < len) u8g2.drawStr(11 + u8g2.getStrWidth(buf) + 1, 56, "_");
    
    u8g2.sendBuffer();
    updateLEDs();
    delay(80 + random(40));
  }
  
  // Final display
  u8g2.clearBuffer();
  u8g2.drawXBMP(34, 7, 58, 30, image_Connected_bits);
  u8g2.drawStr(11, 56, text);
  u8g2.sendBuffer();
}

void showRedNoScreen() {
  u8g2.setFont(u8g2_font_t0_13b_tr);
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);
  
  char buf[32] = "";
  const char* text = MSG_RED_NO;
  int len = strlen(text);
  
  for(int i=0; i<=len; i++) {
    if(i < len) {
      buf[i] = text[i];
      buf[i+1] = '\0';
    }
    
    u8g2.clearBuffer();
    u8g2.drawXBMP(33, 6, 62, 31, image_Error_bits);
    u8g2.drawStr(21, 56, buf);
    if(i < len) u8g2.drawStr(21 + u8g2.getStrWidth(buf) + 1, 56, "_");
    
    u8g2.sendBuffer();
    updateLEDs();
    delay(80 + random(40));
  }
  
  // Final display
  u8g2.clearBuffer();
  u8g2.drawXBMP(33, 6, 62, 31, image_Error_bits);
  u8g2.drawStr(21, 56, text);
  u8g2.sendBuffer();
}

void showPassportHappyScreen() {
  u8g2.setFont(u8g2_font_t0_13b_tr);
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);
  
  char buf[32] = "";
  const char* text = "Knew it";
  int len = strlen(text);
  
  for(int i=0; i<=len; i++) {
    if(i < len) {
      buf[i] = text[i];
      buf[i+1] = '\0';
    }
    
    u8g2.clearBuffer();
    u8g2.drawXBMP(9, 7, 46, 49, image_passport_happy1_bits);
    u8g2.drawStr(68, 36, buf);
    if(i < len) u8g2.drawStr(68 + u8g2.getStrWidth(buf) + 1, 36, "_");
    
    u8g2.sendBuffer();
    updateLEDs();
    delay(80 + random(40));
  }
  
  // Final display
  u8g2.clearBuffer();
  u8g2.drawXBMP(9, 7, 46, 49, image_passport_happy1_bits);
  u8g2.drawStr(68, 36, text);
  u8g2.sendBuffer();
}

void showPassportBadScreen() {
  u8g2.setFont(u8g2_font_t0_13b_tr);
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);
  
  // First line: "Wrong"
  char buf1[32] = "";
  const char* text1 = "Wrong";
  int len1 = strlen(text1);
  
  for(int i=0; i<=len1; i++) {
    if(i < len1) {
      buf1[i] = text1[i];
      buf1[i+1] = '\0';
    }
    
    u8g2.clearBuffer();
    u8g2.drawXBMP(9, 7, 46, 49, image_passport_bad1_bits);
    u8g2.drawStr(75, 29, buf1);
    if(i < len1) u8g2.drawStr(75 + u8g2.getStrWidth(buf1) + 1, 29, "_");
    
    u8g2.sendBuffer();
    updateLEDs();
    delay(80 + random(40));
  }
  
  // Second line: "Answer"
  char buf2[32] = "";
  const char* text2 = "Answer";
  int len2 = strlen(text2);
  
  for(int i=0; i<=len2; i++) {
    if(i < len2) {
      buf2[i] = text2[i];
      buf2[i+1] = '\0';
    }
    
    u8g2.clearBuffer();
    u8g2.drawXBMP(9, 7, 46, 49, image_passport_bad1_bits);
    u8g2.drawStr(75, 29, text1);
    u8g2.drawStr(72, 44, buf2);
    if(i < len2) u8g2.drawStr(72 + u8g2.getStrWidth(buf2) + 1, 44, "_");
    
    u8g2.sendBuffer();
    updateLEDs();
    delay(80 + random(40));
  }
  
  // Final display
  u8g2.clearBuffer();
  u8g2.drawXBMP(9, 7, 46, 49, image_passport_bad1_bits);
  u8g2.drawStr(75, 29, text1);
  u8g2.drawStr(72, 44, text2);
  u8g2.sendBuffer();
}

void showControlScreen1() {
  u8g2.clearBuffer();
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);
  u8g2.drawXBMP(0, 15, 116, 49, image_Scanning_bits);
  u8g2.setFont(u8g2_font_ncenB08_tr);
  u8g2.drawStr(0, 11, MSG_CONTROL_1);
  u8g2.drawStr(73, 59, MSG_CONTROL_2);
  u8g2.sendBuffer();
}

void showControlScreen2() {
  u8g2.clearBuffer();
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);
  u8g2.drawXBMP(0, 15, 116, 49, image_Scanning_bits);
  u8g2.setFont(u8g2_font_t0_13b_tr);
  u8g2.drawStr(29, 11, MSG_CONTROL_3);
  u8g2.sendBuffer();
}

void showValentineScreen() {
  // Custom typewriter with blinking heart
  u8g2.setFont(u8g2_font_t0_13b_tr);
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);
  
  char buf1[32] = "";
  char buf2[32] = "";
  const char* line1 = "Gargi, will you";
  const char* line2 = "Be my valentine ?";
  
  // Type line 1
  int len1 = strlen(line1);
  for(int i=0; i<=len1; i++) {
    if(i < len1) {
      buf1[i] = line1[i];
      buf1[i+1] = '\0';
    }
    
    u8g2.clearBuffer();
    u8g2.drawStr(11, 18, buf1);
    if(i < len1) u8g2.drawStr(11 + u8g2.getStrWidth(buf1) + 1, 18, "_");
    
    // Blinking heart
    if((millis() / 300) % 2 == 0) {
      u8g2.drawXBMP(56, 41, 15, 16, image_cards_hearts_bits);
    }
    
    u8g2.sendBuffer();
    updateLEDs();
    delay(80 + random(40));
  }
  
  // Type line 2
  int len2 = strlen(line2);
  for(int i=0; i<=len2; i++) {
    if(i < len2) {
      buf2[i] = line2[i];
      buf2[i+1] = '\0';
    }
    
    u8g2.clearBuffer();
    u8g2.drawStr(11, 18, line1);
    u8g2.drawStr(3, 33, buf2);
    if(i < len2) u8g2.drawStr(3 + u8g2.getStrWidth(buf2) + 1, 33, "_");
    
    // Blinking heart
    if((millis() / 300) % 2 == 0) {
      u8g2.drawXBMP(56, 41, 15, 16, image_cards_hearts_bits);
    }
    
    u8g2.sendBuffer();
    updateLEDs();
    delay(80 + random(40));
  }
  
  // Final display with steady heart
  u8g2.clearBuffer();
  u8g2.drawStr(11, 18, line1);
  u8g2.drawStr(3, 33, line2);
  u8g2.drawXBMP(56, 41, 15, 16, image_cards_hearts_bits);
  u8g2.sendBuffer();
}

void animShutdown() {
  oledTypewriter(MSG_SLEEP_1, MSG_SLEEP_2); 
  
  // Fade out softly
  for(int b=150; b>=0; b-=5) {
    for(int i=0; i<ACTIVE_LED_COUNT; i++) {
       bodyStrip.setPixelColor(i, bodyStrip.Color(b, 0, b/3));
    }
    buttonStrip.setBrightness(b);
    bodyStrip.show();
    buttonStrip.show();
    delay(20);
  }
  forceHardReset();
  u8g2.clearDisplay();
}

// Non-blocking Animation Loop
void updateLEDs() {
  unsigned long now = millis();
  
  // 1. BODY STRIP: SOFT ROMANCE (Always Active)
  if (currentState == STATE_CELEBRATION) {
      float wave = 0.5 + 0.5 * sin(now / 1000.0 * PI);
      for(int i=0; i<ACTIVE_LED_COUNT; i++) {
          float localWave = 0.5 + 0.5 * sin((now / 800.0 * PI) + (i * 0.5));
          int r = 255;
          int g = 20 + (80 * localWave);
          int b = 30 + (90 * localWave);
          bodyStrip.setPixelColor(i, bodyStrip.Color(r, g, b));
      }
  } else {
    // CANDLELIGHT BREATHING (IDLE)
    for(int i=0; i<ACTIVE_LED_COUNT; i++) {
      int offset = i * 40; 
      float breathe = (exp(sin((now - offset) / 2500.0 * PI)) - 0.36787944) * 108.0;
      int val = map(breathe, 0, 255, 20, 100);
      bodyStrip.setPixelColor(i, bodyStrip.Color(val, val/4, val/3)); 
    }
  }
  for(int i=ACTIVE_LED_COUNT; i<PHYSICAL_LED_COUNT; i++) bodyStrip.setPixelColor(i, 0);

  // 2. BUTTON STRIP
  if (!isTrickReveal) {
      int softPulse = 80 + (int)(sin(now / 800.0) * 60); 
      int panicPulse = 100 + (int)(sin(now / 150.0) * 100); 

      buttonStrip.clear();

      switch (currentState) {
        case STATE_SWAP_MODE:
          if ((now / 150) % 2 == 0) {
             buttonStrip.setPixelColor(0, buttonStrip.Color(0, 255, 0)); // Pure Green
             buttonStrip.setPixelColor(2, buttonStrip.Color(255, 0, 0)); // Pure Red
          } else {
             buttonStrip.setPixelColor(0, buttonStrip.Color(255, 0, 0)); // Pure Red
             buttonStrip.setPixelColor(2, buttonStrip.Color(0, 255, 0)); // Pure Green
          }
          break;

        case STATE_FINAL_PLEA:
          buttonStrip.setPixelColor(0, buttonStrip.Color(0, panicPulse, 50)); 
          buttonStrip.setPixelColor(2, buttonStrip.Color(0, panicPulse, 50));
          break;

        case STATE_CELEBRATION:
          {
            int winPulse = 100 + (int)(sin(now / 300.0) * 155); 
            if (winPulse < 0) winPulse = 0;
            buttonStrip.fill(buttonStrip.Color(winPulse/4, 200, winPulse/4));
          }
          break;

        case STATE_FAIR_RIGHT:
        default: // IDLE & FAIR RIGHT
          buttonStrip.setPixelColor(0, buttonStrip.Color(softPulse, 0, 0)); 
          buttonStrip.setPixelColor(2, buttonStrip.Color(0, softPulse, 0)); 
          break;
      }
  }

  bodyStrip.show();
  buttonStrip.show();
}

// ================= NON-BLOCKING TYPEWRITER SYSTEM =================
void startNonBlockingTypewriter(const char* l1, const char* l2, const char* l3) {
  typewriterActive = true;
  typewriterCharIndex = 0;
  typewriterLine = 1;
  typewriterStartTime = millis();
  
  // Handle newline characters in l1
  if (l1) {
    String text1 = String(l1);
    int newlinePos = text1.indexOf('\n');
    if (newlinePos != -1 && !l2) {
      // Split on newline if no l2 provided
      typewriterText1 = text1.substring(0, newlinePos);
      typewriterText2 = text1.substring(newlinePos + 1);
      typewriterText3 = l3 ? String(l3) : "";
    } else {
      typewriterText1 = text1;
      typewriterText2 = l2 ? String(l2) : "";
      typewriterText3 = l3 ? String(l3) : "";
    }
  } else {
    typewriterText1 = "";
    typewriterText2 = l2 ? String(l2) : "";
    typewriterText3 = l3 ? String(l3) : "";
  }
}

void updateNonBlockingTypewriter() {
  if (!typewriterActive) return;
  
  unsigned long now = millis();
  if (now - typewriterStartTime < 80 + random(40)) return; // Timing control
  
  typewriterStartTime = now;
  u8g2.setFont(u8g2_font_t0_13b_tr);
  u8g2.clearBuffer();
  
  // Display completed lines
  if (typewriterLine > 1 && typewriterText1.length() > 0) {
    int w1 = u8g2.getStrWidth(typewriterText1.c_str());
    u8g2.drawStr((128-w1)/2, typewriterText2.length() > 0 ? 25 : 36, typewriterText1.c_str());
  }
  if (typewriterLine > 2 && typewriterText2.length() > 0) {
    int w2 = u8g2.getStrWidth(typewriterText2.c_str());
    u8g2.drawStr((128-w2)/2, 45, typewriterText2.c_str());
  }
  
  // Current line being typed
  String currentText = "";
  String* targetText = nullptr;
  int yPos = 36;
  
  if (typewriterLine == 1 && typewriterText1.length() > 0) {
    targetText = &typewriterText1;
    yPos = typewriterText2.length() > 0 ? 25 : 36;
  } else if (typewriterLine == 2 && typewriterText2.length() > 0) {
    targetText = &typewriterText2;
    yPos = 45;
  } else if (typewriterLine == 3 && typewriterText3.length() > 0) {
    targetText = &typewriterText3;
    yPos = 60;
  }
  
  if (targetText && typewriterCharIndex < targetText->length()) {
    currentText = targetText->substring(0, typewriterCharIndex + 1);
    int w = u8g2.getStrWidth(currentText.c_str());
    u8g2.drawStr((128-w)/2, yPos, currentText.c_str());
    u8g2.drawStr((128-w)/2 + w + 1, yPos, "_");
    typewriterCharIndex++;
  } else {
    // Current line complete, move to next or finish
    if (targetText) {
      int w = u8g2.getStrWidth(targetText->c_str());
      u8g2.drawStr((128-w)/2, yPos, targetText->c_str());
    }
    
    typewriterCharIndex = 0;
    typewriterLine++;
    
    // Check if we've completed all available lines
    bool line1Done = (typewriterText1.length() == 0) || (typewriterLine > 1);
    bool line2Done = (typewriterText2.length() == 0) || (typewriterLine > 2);
    bool line3Done = (typewriterText3.length() == 0) || (typewriterLine > 3);
    
    if (line1Done && line2Done && line3Done) {
      typewriterActive = false;
    }
  }
  
  u8g2.sendBuffer();
}

void startNoResponseTimer() {
  showingNoResponse = true;
  noResponseTimerStarted = false; // Timer will start when typewriter finishes
  noResponseDisplayTime = 0;
}

// ================= IDLE DISPLAY UPDATE =================
void updateIdleDisplay() {
  if (currentState == STATE_IDLE && !typewriterActive) {
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_t0_13b_tr);
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);
    
    u8g2.drawStr(11, 18, "Gargi, will you");
    u8g2.drawStr(3, 33, "Be my valentine ?");
    
    // Blinking heart
    if((millis() / 300) % 2 == 0) {
      u8g2.drawXBMP(56, 41, 15, 16, image_cards_hearts_bits);
    }
    
    u8g2.sendBuffer();
  }
}

// ================= SETUP =================
void setup() {
  Serial.begin(115200);
  forceHardReset();

  pinMode(BTN_YES_PIN, INPUT_PULLUP);
  pinMode(BTN_NO_PIN, INPUT_PULLUP);

  Wire.begin();
  u8g2.begin();

  lastBtnYesReading = digitalRead(BTN_YES_PIN);
  lastBtnNoReading = digitalRead(BTN_NO_PIN);
  btnYesStable = lastBtnYesReading;
  btnNoStable = lastBtnNoReading;

  animBoot();
  lastActivityTime = millis();
}

// ================= LOOP =================
void loop() {
  unsigned long now = millis();
  
  // --- 1. INPUT READING ---
  bool readYes = digitalRead(BTN_YES_PIN);
  bool readNo = digitalRead(BTN_NO_PIN);
  bool btnPressed = false;
  bool isYesBtn = false; 

  if (readYes != lastBtnYesReading || readNo != lastBtnNoReading) {
    lastDebounceTime = now;
  }
  lastBtnYesReading = readYes;
  lastBtnNoReading = readNo;

  if ((now - lastDebounceTime) > DEBOUNCE_DELAY) {
    if (readYes != btnYesStable) {
      btnYesStable = readYes;
      if (btnYesStable == LOW) { btnPressed = true; isYesBtn = true; }
    }
    if (readNo != btnNoStable) {
      btnNoStable = readNo;
      if (btnNoStable == LOW) { btnPressed = true; isYesBtn = false; }
    }
  }

  // --- 2. LOGIC ---
  if (btnPressed) {
    lastActivityTime = now; 

    // INTRO SEQUENCE NAVIGATION
    if (currentState == STATE_INTRO_DOLPHIN) {
      currentState = STATE_INTRO_1;
      showIntroMessage(MSG_INTRO_1);
    }
    else if (currentState == STATE_INTRO_1) {
      currentState = STATE_VALENTINE_CHECK;
      startNonBlockingTypewriter(MSG_VALENTINE_CHECK);
    }
    else if (currentState == STATE_VALENTINE_CHECK) {
      if (isYesBtn) {
        currentState = STATE_INTRO_REMEMBER;
        showRememberScreen();
      } else {
        currentState = STATE_GOODNIGHT;
        startNonBlockingTypewriter(MSG_GOODNIGHT);
        stateStartTime = now;
      }
    }
    else if (currentState == STATE_INTRO_REMEMBER) {
      currentState = STATE_INTRO_GREEN;
      showGreenYesScreen();
    }
    else if (currentState == STATE_INTRO_GREEN) {
      currentState = STATE_INTRO_RED;
      showRedNoScreen();
    }
    else if (currentState == STATE_INTRO_RED) {
      currentState = STATE_INTRO_2;
      startNonBlockingTypewriter(MSG_INTRO_2_1, MSG_INTRO_2_2);
    }
    else if (currentState == STATE_INTRO_2) {
      currentState = STATE_INTRO_3;
      showIntroMessage(MSG_INTRO_3);
    }
    else if (currentState == STATE_INTRO_3) {
      currentState = STATE_INTRO_4;
      startNonBlockingTypewriter(MSG_INTRO_4_1, MSG_INTRO_4_2);
    }
    else if (currentState == STATE_INTRO_4) {
      currentState = STATE_CUTE_RESPONSE;
      if (isYesBtn) {
        lastCuteResponseWasYes = true;
        showPassportHappyScreen();
      } else {
        lastCuteResponseWasYes = false;
        showPassportBadScreen();
      }
      stateStartTime = now; // Start timer for auto-advance
    }
    else if (currentState == STATE_INTRO_5) {
      currentState = STATE_INTRO_6;
      startNonBlockingTypewriter(MSG_INTRO_6);
    }
    else if (currentState == STATE_INTRO_6) {
      currentState = STATE_IDLE;
      showValentineScreen();
    }
    // STATE_CUTE_RESPONSE is handled by auto-advance timer, no manual button handling needed
    // MAIN VALENTINE SEQUENCE
    else if (currentState == STATE_CELEBRATION) {
      if (now - stateStartTime > 500) { 
        currentState = STATE_JOB_DONE;
        startNonBlockingTypewriter(MSG_JOB_DONE_1, MSG_JOB_DONE_2);
        stateStartTime = now;
        lastActivityTime = now; 
      }
    }
    else if (currentState == STATE_JOB_DONE) {
      currentState = STATE_LEAVE_QUESTION;
      startNonBlockingTypewriter(MSG_LEAVE_QUESTION);
    }
    else if (currentState == STATE_LEAVE_QUESTION) {
      if (isYesBtn) {
        currentState = STATE_GOODNIGHT;
        startNonBlockingTypewriter(MSG_JOB_GOODNIGHT);
        stateStartTime = now;
      } else {
        currentState = STATE_DEFIANT_RESPONSE;
        startNonBlockingTypewriter(MSG_CANT_CONTROL_1, MSG_CANT_CONTROL_2);
        stateStartTime = now;
      }
    }
    else if (currentState == STATE_DEFIANT_RESPONSE) {
      // Any button press goes to goodnight
      currentState = STATE_GOODNIGHT;
      startNonBlockingTypewriter(MSG_JOB_GOODNIGHT);
      stateStartTime = now;
    }
    else if (currentState == STATE_FINAL_PLEA) {
      currentState = STATE_CELEBRATION;
      startNonBlockingTypewriter(MSG_WIN_FINAL_1, MSG_WIN_FINAL_2, MSG_WIN_FINAL_3);
      stateStartTime = now;
    }
    else if (currentState == STATE_FAIR_RIGHT) {
      if (isYesBtn) {
        currentState = STATE_CELEBRATION;
        startNonBlockingTypewriter(MSG_WIN_STD_1, MSG_WIN_STD_2, MSG_WIN_STD_3);
        stateStartTime = now;
      } else {
        currentState = STATE_FINAL_PLEA;
        showControlScreen1();
        controlScreenStartTime = now;
        showingControlScreen2 = false;
      }
    }
    else if (currentState == STATE_SWAP_MODE) {
      // IMMEDIATE UPDATE BEFORE TEXT STARTS
      isTrickReveal = true; 
      
      buttonStrip.clear();
      if (isYesBtn) { 
        buttonStrip.setPixelColor(0, buttonStrip.Color(255, 0, 0)); 
        buttonStrip.setPixelColor(2, buttonStrip.Color(0, 255, 0));
      } else { 
        buttonStrip.setPixelColor(0, buttonStrip.Color(0, 255, 0));
        buttonStrip.setPixelColor(2, buttonStrip.Color(255, 0, 0)); 
      }
      buttonStrip.show(); // FORCE SHOW NOW

      startNonBlockingTypewriter(MSG_TRICK_REVEAL); 
      trickRevealStartTime = now;
      trickRevealWaiting = true;
    }
    else if (currentState == STATE_IDLE) {
      if (isYesBtn) {
        currentState = STATE_CELEBRATION;
        startNonBlockingTypewriter(MSG_WIN_STD_1, MSG_WIN_STD_2, MSG_WIN_STD_3);
        stateStartTime = now;
      } else {
        noCount++;
        if (noCount >= TRIGGER_COUNT) {
          currentState = STATE_SWAP_MODE;
          startNonBlockingTypewriter(MSG_TRICK_PROMPT);
        } else {
          currentState = STATE_NO_RESPONSE;
          startNonBlockingTypewriter(NO_RESPONSES[noCount - 1]);
          startNoResponseTimer();
        }
      }
    }
  }

  // --- 3. AUTO RESET & AUTO-ADVANCE ---
  if (currentState == STATE_CELEBRATION && (now - stateStartTime > CELEBRATION_DURATION)) {
      currentState = STATE_JOB_DONE;
      startNonBlockingTypewriter(MSG_JOB_DONE_1, MSG_JOB_DONE_2);
      stateStartTime = now;
      lastActivityTime = now; 
  }
  
  // Auto-advance from job done to leave question after 3 seconds
  if (currentState == STATE_JOB_DONE && (now - stateStartTime > 3000)) {
    currentState = STATE_LEAVE_QUESTION;
    startNonBlockingTypewriter(MSG_LEAVE_QUESTION);
    stateStartTime = now;
  }
  
  // Auto-advance from defiant response to goodnight after 3 seconds
  if (currentState == STATE_DEFIANT_RESPONSE && (now - stateStartTime > 3000)) {
    currentState = STATE_GOODNIGHT;
    startNonBlockingTypewriter(MSG_JOB_GOODNIGHT);
    stateStartTime = now;
  }
  
  // Auto-advance from cute response after 2 seconds
  if (currentState == STATE_CUTE_RESPONSE && (now - stateStartTime > 2000)) {
      if (lastCuteResponseWasYes) {
        // Only advance to next intro message if they said yes
        currentState = STATE_INTRO_5;
        startNonBlockingTypewriter(MSG_INTRO_5);
        stateStartTime = now;
      } else {
        // Loop back to cute question if they said no
        currentState = STATE_INTRO_4;
        startNonBlockingTypewriter(MSG_INTRO_4_1, MSG_INTRO_4_2);
        stateStartTime = now;
      }
  }
  
  // Auto-advance from goodnight to deep sleep after 2 seconds
  if (currentState == STATE_GOODNIGHT && (now - stateStartTime > 2000)) {
    animShutdown();
    esp_deep_sleep_enable_gpio_wakeup(1ULL << BTN_YES_GPIO, ESP_GPIO_WAKEUP_GPIO_LOW);
    delay(100);
    esp_deep_sleep_start();
  }

  updateLEDs();
  updateNonBlockingTypewriter();
  updateIdleDisplay();
  
  // Handle NO response timer - start 2-second timer when typewriter finishes
  if (showingNoResponse && currentState == STATE_NO_RESPONSE) {
    if (!typewriterActive && !noResponseTimerStarted) {
      // Typewriter just finished, start the 2-second timer now
      noResponseDisplayTime = now;
      noResponseTimerStarted = true;
    }
    if (noResponseTimerStarted && (now - noResponseDisplayTime > 2000)) {
      // 2 seconds have passed since typewriter finished
      showingNoResponse = false;
      noResponseTimerStarted = false;
      currentState = STATE_IDLE;
      showValentineScreen();
    }
  }
  
  // Handle trick reveal timer
  if (trickRevealWaiting && (now - trickRevealStartTime > 2000)) {
    trickRevealWaiting = false;
    isTrickReveal = false;
    currentState = STATE_FAIR_RIGHT;
    startNonBlockingTypewriter(MSG_FAIR_1, MSG_FAIR_2);
  }
  
  // Handle control screen alternation
  if (currentState == STATE_FINAL_PLEA && (now - controlScreenStartTime > 1500)) {
    if (!showingControlScreen2) {
      showControlScreen2();
      showingControlScreen2 = true;
    } else {
      showControlScreen1();
      showingControlScreen2 = false;
    }
    controlScreenStartTime = now;
  }

  // --- 4. SLEEP ---
  if (now - lastActivityTime >= INACTIVITY_TIMEOUT) {
    animShutdown();
    esp_deep_sleep_enable_gpio_wakeup(1ULL << BTN_YES_GPIO, ESP_GPIO_WAKEUP_GPIO_LOW);
    delay(100);
    esp_deep_sleep_start();
  }
  
  delay(10); 
}